import { http } from '@kit.NetworkKit';

interface AmapPhoto {
  url: string;
}

interface AmapBizExt {
  rating: string;
  cost: string;
}

interface AmapPoi {
  id: string;
  name: string;
  type: string;
  address: string;
  distance: string;
  photos: AmapPhoto[];
  biz_ext: AmapBizExt;
}

interface AmapResponse {
  status: string;
  pois: AmapPoi[];
}

export interface ScenicSpot {
  id: string;
  name: string;
  image: string;
  rating: string;
  price: string;
  isFree: boolean;
  distance: number;
  address: string;
  tags: string[];
  isMuseum: boolean;
}

export class AmapSpotService {
  private static readonly API_KEY = 'd4552bc3e20af2857f9cfd5ac95ded1d';

  // ğŸ”¹ åœºé¦†å·²å•ç‹¬é€‚é…çš„â€œè¶…å¤§åŸå¸‚â€
  private static readonly VENUE_EXCLUDED_CITIES = [
    'åŒ—äº¬',
    'å¤©æ´¥',
    'ä¸Šæµ·',
    'æ­¦æ±‰',
    'é‡åº†',
    'æˆéƒ½'
  ];

  // ğŸ”¹ å…¨å›½é¡¶çº§åœ°æ ‡å…œåº•
  private static readonly TOP_LANDMARK_REGEX =
    /æ•…å®«|å¤©å®‰é—¨|é¢å’Œå›­|å¤©å›|é•¿åŸ|åœ†æ˜å›­|è¥¿æ¹–|é»„é¹¤æ¥¼|å²³é˜³æ¥¼|æ»•ç‹é˜|å…µé©¬ä¿‘|å¸ƒè¾¾æ‹‰å®«|ä¹å¯¨æ²Ÿ|å¼ å®¶ç•Œ|æ³°å±±|åå±±|åµ©å±±/;

  static async fetchSpots(city: string): Promise<ScenicSpot[]> {
    const key = AmapSpotService.API_KEY;
    const keywords = encodeURIComponent('æ™¯åŒº|é£æ™¯åèƒœ|ä¸–ç•Œé—äº§|åœ°æ ‡');

    const url = `https://restapi.amap.com/v3/place/text?key=${key}&keywords=${keywords}&city=${encodeURIComponent(
      city
    )}&offset=50&page=1&extensions=all&sortrule=weight`;

    const isVenueExcludedCity =
      AmapSpotService.VENUE_EXCLUDED_CITIES.includes(city);

    const httpRequest = http.createHttp();

    try {
      const response = await httpRequest.request(url);
      if (response.responseCode === 200) {
        const result = JSON.parse(response.result as string) as AmapResponse;

        if (result.status === '1' && result.pois) {
          return result.pois
            .filter((poi) => {
              const name = poi.name || '';
              const rating = parseFloat(poi.biz_ext?.rating || '0');
              const photos = poi.photos || [];
              const hasPhoto = photos.length > 0;

              if (AmapSpotService.TOP_LANDMARK_REGEX.test(name)) {
                return hasPhoto;
              }

              const junkRegex =
                /(å•æ‰€|åœè½¦åœº|å…¥å£|å‡ºå£|å”®ç¥¨å¤„|æ¸¸å®¢æœåŠ¡ä¸­å¿ƒ|æœåŠ¡åŒº|ç å¤´|ç«™|è·¯æ®µ)/;
              if (junkRegex.test(name)) return false;

              const subSpotRegex =
                /-(å…¥å£|å‡ºå£|åœè½¦|å”®ç¥¨)|Â·(å…¥å£|å‡ºå£|å”®ç¥¨)/;
              if (subSpotRegex.test(name)) return false;

              const isVenue =
                /(åšç‰©é¦†|çºªå¿µé¦†|ç¾æœ¯é¦†|ç§‘æŠ€é¦†)/.test(name);

              if (isVenueExcludedCity) {
                if (isVenue) return false;
              } else {
                if (isVenue && rating < 4.5) return false;
              }

              if (
                /(å¹¿åœº|å•†ä¸šè¡—|æ­¥è¡Œè¡—|å•†åœˆ)/.test(name) &&
                  (isVenueExcludedCity || rating < 4.4)
              ) {
                return false;
              }

              let score = 0;

              if (rating >= 4.6) score += 3;
              else if (rating >= 4.3) score += 2;
              else if (rating >= 4.0) score += 1;

              if (photos.length >= 6) score += 3;
              else if (photos.length >= 3) score += 2;
              else if (photos.length >= 1) score += 1;

              if (poi.type?.includes('é£æ™¯åèƒœ')) score += 2;
              if (/æ™¯åŒº|åèƒœ|é—å€|å…¬å›­$/.test(name)) score += 2;

              return isVenueExcludedCity ? score >= 7 : score >= 6;
            })
            .map((poi): ScenicSpot => {
              const costValue = poi.biz_ext?.cost || '0';
              const photos = poi.photos || [];

              let image = '';
              if (photos.length > 0) {
                const index = Math.floor(photos.length / 2);
                image = photos[index]?.url || photos[0].url;
              }

              return {
                id: poi.id,
                name: poi.name,
                image,
                rating: poi.biz_ext?.rating || '4.0',
                price: costValue,
                isFree: parseInt(costValue) === 0 || costValue === '',
                distance: parseInt(poi.distance || '0'),
                address: poi.address,
                tags: AmapSpotService.parseProTags(poi),
                isMuseum: /(åšç‰©é¦†|çºªå¿µé¦†)/.test(poi.name)
              };
            });
        }
      }
    } catch (e) {
      console.error('Fetch Scenic Data Failed', e);
    }

    return [];
  }

  private static parseProTags(poi: AmapPoi): string[] {
    const tags: string[] = [];
    const name = poi.name || '';
    const typeStr = poi.type || '';

    if (typeStr.includes('5A')) tags.push('5Aæ™¯åŒº');
    else if (typeStr.includes('4A')) tags.push('4Aæ™¯åŒº');
    else if (typeStr.includes('3A')) tags.push('3Aæ™¯åŒº');

    const natureRegex = /å±±|æ¹–|æµ·|å²›|æ—|å³°|æ³‰|æ»©|ç€‘|è‰åŸ/;
    if (natureRegex.test(name) || typeStr.includes('è‡ªç„¶')) {
      tags.push('è‡ªç„¶');
    } else {
      tags.push('äººæ–‡');
    }

    if (parseInt(poi.biz_ext?.cost || '0') === 0) {
      tags.push('å…è´¹');
    }

    return tags.slice(0, 3);
  }
}
